# `repair_inline_parentheses.py` 处理逻辑说明

该模块的目标：当 GPT 输出丢失了行内公式定界符时（把 `\( ... \)` 变成 `( ... )`），尽量**保守且准确**地把“看起来像数学的括号内容”还原为 `\( ... \)`，并避免误伤普通文字括号。\n+\n同时提供一个**激进策略**选项，用于识别 `(n)/(a)/(x)/(F')/(f(x))` 等短 token 形式的括号内容，但可能误伤普通英文括号。

> 核心原则：**只在高置信度“数学内容”时替换**，同时**跳过已有数学环境**，避免重复包裹。

---

## 1. 跳过已有数学环境

模块先定义 `_MATH_SPAN_RE`，用于识别并保护以下已有数学片段：

- `$$ ... $$`
- `\[ ... \]`
- `\begin{equation} ... \end{equation}`（含 `*`）
- `\begin{align} ... \end{align}`（含 `*`）
- `\( ... \)`
- `$ ... $`（单美元号行内公式）

处理时会把全文切分为“数学片段 / 非数学片段”两类，仅在**非数学片段**中尝试修复 `( ... )`。

---

## 2. 判断括号内容是否“像数学”（保守策略）

函数 `_is_mathish(text)` 用来判断括号内是否是数学表达式，采用**保守规则**：

### 2.1 明确排除
- 如果内容包含中日韩字符（CJK），直接判定为**非数学**，不替换。

### 2.2 认为“像数学”的特征（满足任一即可）
- 含 LaTeX 命令：如 `\nabla`, `\frac`, `\mathbb` 等
- 含上标/下标：`^` 或 `_`
- 含比较符：`=`, `<`, `>`
- 含基本运算：如 `a+b`, `x*y`, `x/y` 等
- 含绝对值形式：`|...|`

如果不满足以上特征，括号将保持原样。
\n+### 2.3 激进策略（短 token 识别）\n+\n激进策略会把**无空格的短 token** 也当作数学，例如：\n+\n- `(n)`, `(a)`, `(x)`\n- `(F')`, `(T_n)`\n- `(f(x))`\n+\n规则要点：\n- 若括号内含空格，则不替换\n- 若包含 CJK 字符，则不替换\n- 允许字母/数字、`^`/`_`、`'`/`′`、花括号、以及嵌套 `()`\n\n@@\n-如需更“激进”的替换（例如把 `(x)` 也当作数学），可以放宽 `_is_mathish` 的判断规则或去掉“紧贴字母数字”限制，但会显著增加误伤风险。\n+如需更“激进”的替换（例如把 `(x)` 也当作数学），可启用激进策略，但会显著增加误伤风险。

---

## 3. 括号配对与嵌套处理

模块使用 `_find_parentheses_pairs` 来做**配对扫描**：

- 支持嵌套括号，类似栈结构
- 会忽略转义括号（如 `\(` 和 `\)`），避免误判

接着筛选候选括号：

- 内容不能跨行（不能包含 `\n`）
- 必须通过 `_is_mathish` 判断
- **括号左右不能紧贴字母/数字/下划线/反斜杠**
  - 例如 `f(x)`、`abc(x^2)` 被视为函数调用，避免误替换

---

## 4. 避免嵌套替换

当存在嵌套括号时，模块会优先选择**外层括号**，避免出现：

```
\( ... \( ... \) ... \)
```

实现方式：

- 按“起点靠前、跨度更大优先”排序
- 若候选区间与已选区间重叠，则跳过

最后从**后往前**替换，防止索引错位。

---

## 5. 典型示例

### ✅ 会被替换
```
(\nabla f(x^\star)=0)
(|\nabla f(x^\star)|^2>0)
(d=\nabla f(x^\star))
```

输出：
```
\(\nabla f(x^\star)=0\)
\(|\nabla f(x^\star)|^2>0\)
\(d=\nabla f(x^\star)\)
```

### ❌ 不会被替换
```
(see Appendix)
f(x)
```

---

## 6. 与其它修复规则的组合顺序

在 `text_processing.py` 中，该函数通常在：

1) `repair_display_brackets` 之后
2) 其它行内公式规范/替换之前

这样可以先修复 GPT 缺失斜杠的问题，再进入其它数学格式化逻辑。

---

## 7. 设计取舍

- **保守优先**：宁可少替换，也避免误伤普通文本。
- **适配 GPT 错误**：重点修复 `\( ... \)` 变成 `( ... )` 的场景。
- **兼容性**：对已存在数学环境不做二次处理。

---

如需更“激进”的替换（例如把 `(x)` 也当作数学），可以放宽 `_is_mathish` 的判断规则或去掉“紧贴字母数字”限制，但会显著增加误伤风险。
